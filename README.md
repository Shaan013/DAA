---

# Design and Analysis of Algorithms (DAA) - Java Practical Repository

This repository contains Java implementations of various practicals based on the Design and Analysis of Algorithms (DAA) course. The practicals involve common algorithms and problem-solving techniques used in computer science, including sorting, searching, greedy algorithms, dynamic programming, and more.

## Table of Contents
- [Introduction](#introduction)
- [Practicals/Tutorials](#practicalstutorials)
- [Requirements](#requirements)
- [Installation](#installation)
- [Usage](#usage)
- [Contributing](#contributing)
- [License](#license)

## Introduction

This repository includes Java implementations for the following DAA practicals:

1. **Bubble Sort**
2. **Selection Sort**
3. **Heap Sort**
4. **Sequential and Binary Search**
5. **Merge Sort**
6. **Quick Sort**
7. **Greedy Algorithms (Making Change Problem)**
8. **Knapsack Problem using Greedy Algorithm**
9. **Making Change Problem using Dynamic Programming**
10. **Knapsack Problem using Dynamic Programming**
11. **Floyd’s Algorithm for Shortest Path**
12. **Chained Matrix Multiplication using Dynamic Programming**
13. **Longest Common Subsequence using Dynamic Programming**

## Practicals/Tutorials

### 1. **Bubble Sort**
   - **Description**: Sorts the elements of an array in ascending order using the Bubble Sort algorithm.
   - **Analysis**: Time complexity for best, average, and worst cases.
     - Best Case: O(n)  
     - Average Case: O(n²)  
     - Worst Case: O(n²)

### 2. **Selection Sort**
   - **Description**: Sorts the elements of an array in ascending order using the Selection Sort algorithm.
   - **Analysis**: Time complexity for best, average, and worst cases.
     - Best Case: O(n²)  
     - Average Case: O(n²)  
     - Worst Case: O(n²)

### 3. **Heap Sort**
   - **Description**: Implements the Heap Sort algorithm to sort an array in ascending order.
   - **Analysis**: Time complexity for best, average, and worst cases.
     - Best Case: O(n log n)  
     - Average Case: O(n log n)  
     - Worst Case: O(n log n)

### 4. **Sequential Search and Binary Search**
   - **Description**: Searches for a given element from an array using Sequential Search and Binary Search algorithms.
   - **Analysis**: Time complexity for best, average, and worst cases.
     - Sequential Search: O(n)  
     - Binary Search: O(log n)

### 5. **Merge Sort**
   - **Description**: Sorts the elements of an array in ascending order using the Merge Sort algorithm.
   - **Analysis**: Time complexity for best, average, and worst cases.
     - Best Case: O(n log n)  
     - Average Case: O(n log n)  
     - Worst Case: O(n log n)

### 6. **Quick Sort**
   - **Description**: Sorts the elements of an array in ascending order using the Quick Sort algorithm.
   - **Analysis**: Time complexity for best, average, and worst cases.
     - Best Case: O(n log n)  
     - Average Case: O(n log n)  
     - Worst Case: O(n²)

### 7. **Making Change Problem (Greedy Algorithm)**
   - **Description**: Solves the Making Change problem using the Greedy algorithm, which minimizes the number of coins needed to make a given amount.

### 8. **Knapsack Problem (Greedy Algorithm)**
   - **Description**: Solves the Knapsack problem using the Greedy algorithm by selecting items based on their value-to-weight ratio.

### 9. **Making Change Problem (Dynamic Programming)**
   - **Description**: Solves the Making Change problem using Dynamic Programming, ensuring the optimal solution by considering all possible combinations.

### 10. **Knapsack Problem (Dynamic Programming)**
   - **Description**: Solves the Knapsack problem using Dynamic Programming, ensuring the optimal selection of items given a weight constraint.

### 11. **Floyd’s Algorithm for Shortest Path**
   - **Description**: Implements Floyd’s algorithm to find the shortest path between all pairs of vertices in a weighted graph.

### 12. **Chained Matrix Multiplication (Dynamic Programming)**
   - **Description**: Solves the Chained Matrix Multiplication problem using Dynamic Programming to minimize the number of multiplications.

### 13. **Longest Common Subsequence (Dynamic Programming)**
   - **Description**: Solves the Longest Common Subsequence problem using Dynamic Programming to find the longest sequence of characters common to two strings.

## Requirements

- Java Development Kit (JDK) 8 or higher.
- Basic understanding of algorithms and their complexities.
- Text editor or Integrated Development Environment (IDE) like IntelliJ IDEA, Eclipse, or NetBeans.

## Installation

1. Clone the repository to your local machine:

```bash
git clone https://github.com/Shaan013/DAA.git
```

2. Navigate to the project directory:

```bash
cd DAA
```

3. Compile the Java programs using the Java compiler (`javac`):

```bash
javac <ProgramName>.java
```

4. Run the Java programs:

```bash
java <ProgramName>
```

## Usage

For each algorithm or problem, navigate to its respective directory, compile the Java file, and execute it to see the results.

For example, to run **Bubble Sort**:

```bash
cd bubblesort
javac BubbleSort.java
java BubbleSort
```

To run **Knapsack Problem (Dynamic Programming)**:

```bash
cd knapsack
javac Knapsack.java
java Knapsack
```

## Contributing

Contributions are welcome! If you'd like to add new algorithms, fix bugs, or improve the documentation, please fork the repository and submit a pull request.

## License

This repository is licensed under the MIT License. See the LICENSE file for more details.

---
